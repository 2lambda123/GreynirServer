
{% extends "container-normal.html" %}

{% block styles %}

<link href="{{ url_for('static', filename='css/main-bootstrap.css') }}" rel='stylesheet' type='text/css'>

{% endblock %}

{% block content %}

<div class="input-correct">

   <div class="row">

      <div class="col-xs-12" id="txt-div">

         <textarea rows="12" class="form-control input-lg"
            id="txt" tabindex="1" maxlength="16384" autofocus required
            placeholder="Sláðu inn texta til að lesa yfir">
            {{- default_text -}}
         </textarea>

      </div>

   </div>

   <div class="row buttons">
      <div class="col-xs-4 col-sm-3 col-md-2 pull-right">
         <button class="btn btn-success btn-lg btn-block"
            id="txt-ok" title="Lesa yfir" tabindex="3"
            onclick="correct()">
            <span class='glyphicon glyphicon-restart glyphicon-spin-white spin' style="display:none;"></span>
            <span class="glyphicon glyphicon-eye-open normal"></span> Lesa yfir
         </button>
      </div>

      <form id="uploadForm" class="hidden">
         <input id="file-input" type="file" name="filename" onChange="uploadFile()"
         accept="
            .txt,
            .html,
            .rtf,
            .docx,
            text/plain,
            text/html,
            text/rtf,
            application/rtf,
            application/vnd.openxmlformats-officedocument.wordprocessingml.document
         ">
      </form>

      <div class="col-xs-4 col-sm-3 col-md-2 pull-right">
         <button class="btn btn-info btn-lg btn-block"
            id="file-ok" title="Skjal" tabindex="3"
            onclick="selectFile()">
            <span class='glyphicon glyphicon-restart glyphicon-spin-white spin' style="display:none;"></span>
            <span class="glyphicon glyphicon-upload normal"></span> Skjal
         </button>
      </div>

   </div>

</div>

<div id="output" style="display: none;">

   <div class="row">

      <div class="col-xs-12">

         <h3 class="help">Yfirlesinn texti</h3>

         <!--
            The result div contains a list of paragraph divs, each
            consisting of two side-by-side divs for the text
            and its annotations
         -->
         <div id="result">
            <div class="background">
               <span id="no-annotations">
                  Engar athugasemdir <span class="glyphicon glyphicon-circle-ok"></span>
               </span>
            </div>
            <div id="pgs"></div>
         </div>

         <div id="statistics">
            <!-- Statistics go here -->
            <h3>Tölfræði</h3>
            <ul>
               <li>Textinn inniheldur <span id="tok-num">0</span> eindir í
                  <span id="num-sent">0</span> málsgreinum.</li>
               <li>Það tókst að trjágreina <span id="num-parsed-sent">0</span>
                  <span id="paragraphs">málsgreinar</span> eða
                  <span id="num-parsed-ratio">0,0</span>%.</li>
               <li>Margræðnistuðull var
                  <span id="avg-ambig-factor">1,00</span>.</li>
            </ul>
         </div>

      </div>

   </div>
</div>

{% endblock %}

{% block endscripts %}

<script src="{{ url_for('static', filename='js/common.js') }}"></script>
<script src="{{ url_for('static', filename='js/page.js') }}"></script>

<script>

   // Global array linking annotations to token span indices
   var annSpan = [];

   function wait(state, button) {
      // Start or stop a wait spinner
      if (state) {
         // Disable both buttons
         $("#txt-ok, #file-ok").attr("disabled", "disabled");
         $("div#output").css("display", "none");

         // Activate spinner on relevant button
         var sel = button ? button : "#txt-ok, #file-ok";
         $(sel).find('.spin').show();
         $(sel).find('.normal').hide();
      }
      else {
         // Re-enable both buttons
         $("#txt-ok, #file-ok").removeAttr("disabled");
         $("div#output").css("display", "block");

         // Deactivate spinners
         var sel = "#txt-ok, #file-ok";
         $(sel).find('.spin').hide();
         $(sel).find('.normal').show();
      }
   }

   function clearResult() {
      // Clear previous result
      $("div#pgs").html("");
      $("#no-annotations").css("display", "none");
      $(window).off("resize");
      annSpan = [];
      $("div#statistics").css("display", "none");
      // Display progress indicator
      wait(true, "#txt-ok");
   }

   function handleError(xhr, status, errorThrown) {
      /* An error occurred on the server or in the communications */
      var msg = "<b>Villa kom upp</b> í samskiptum við netþjón Greynis";
      if (xhr.status == 413) {
         msg = "<b>Skjalið er of stórt</b> (>1.0 MB)";
      }

      $("div#pgs").html("<p>" + msg + "</p>");
      wait(false);
   }

   function formatAnnotation(txt) {
      // Hack to convert all text within single quotation marks in
      // an annotation to bold, while also escaping the annotation
      // text to valid HTML
      var fmt = txt.replace(/'[^']*'/g, function (s) {
         // Be careful to not use characters that will be HTML-escaped
         // in the dummy markers
         return "[bold]" + s.slice(1, -1) + "[~bold]";
      });
      fmt = escapeHtml(fmt);
      // Replace the dummy markers with HTML tags
      return fmt.replace(/\[bold\]/g, "<b>").replace(/\[~bold\]/g, "</b>");
   }

   function annHoverIn(ev) {
      // Hovering over an annotation
      var wId = $(this).attr("id");
      if (wId === null || wId === undefined) {
         // No id: nothing to do
         return;
      }
      var ix = parseInt(wId.slice(1));
      var span = annSpan[ix];
      if (!span) {
         // No annotation: nothing to do
         return;
      }
      // Add a highlight to all tokens spanned by this annotation
      for (var i = span.start; i <= span.end; i++)
         $("#w" + i).addClass("highlight");
      // Emphasize the path associated with this annotation
      // Note: addClass() doesn't work on SVG elements until jQuery 3.0.
      $("#p" + ix)[0].classList.add("highlight");
   }

   function annHoverOut(ev) {
      // No longer hovering over an annotation
      var wId = $(this).attr("id");
      if (wId === null || wId === undefined) {
         // No id: nothing to do
         return;
      }
      var ix = parseInt(wId.slice(1));
      var span = annSpan[ix];
      if (!span) {
         // No annotation: nothing to do
         return;
      }
      // Remove highlight from all tokens spanned by this annotation
      for (var i = span.start; i <= span.end; i++)
         $("#w" + i).removeClass("highlight");
      // De-emphasize the path associated with this annotation
      $("#p" + ix)[0].classList.remove("highlight");
   }

   function displayAnnotations(j) {
      // Generate HTML for the token list given in j,
      // and insert it into the <div> with id 'pgs'.
      // Also, populate the global w array with the
      // token list.
      // Also, display annotations alongside the original text.
      // The variable x accumulates the content of the #pgs div
      var x = "";
      var lastSp;
      w = []; // Token array (declared as a global in page.js)
      annSpan = []; // Array of annotation token spans
      $.each(j, function(pix, p) {
         // We create a div for each paragraph
         x += "<div class='correct'>\n";
         // Left column: paragraph text
         var left = "";
         // Right column: paragraph annotations
         var right = "";
         // Third child: SVG drawing stuff
         var canvas = "";
         $.each(p, function(six, s) {
            // Sentence s
            lastSp = TP_NONE;
            left += "<span class='sent'>";
            // Note where the sentence starts in the token array
            var six = w.length;
            $.each(s.tokens, function(tix, t) {
               // Token t
               var thisSp = spacing(t);
               // Insert a space in front of this word if required
               // (but never at the start of a sentence)
               if (TP_SPACE[lastSp - 1][thisSp - 1] && tix)
                  left += " ";
               lastSp = thisSp;
               var tx = t.x;
               var cls = [];
               if (t.k == TOK_PUNCTUATION) {
                  // Add space around em-dash
                  if (tx == "—")
                     tx = " — ";
                  cls.push("p");
               }
               else {
                  cls.push("c");
                  tx = tx.replace(" - ", "-"); // Tight hyphen, no whitespace
               }
               // Check whether the token occurs inside an annotation
               // This is fairly inefficient but that is not a problem in practice
               $.each(s.annotations, function(aix, a) {
                  // Annotation a
                  if (tix >= a.start && tix <= a.end) {
                     // The annotation applies to this token:
                     // mark the token
                     if (a.code[0] == "T")
                        // Taboo word warning
                        cls.push("warntok");
                     else
                        // Other error
                        cls.push("errtok");
                     return false; // break from $each loop
                  }
               });
               left += "<i id='w" + w.length +
                  "' class='" + cls.join(" ") + "'>" + tx + "</i>";
               // Append to word/token list
               w.push(t);
            });
            // Accumulate annotations into the right column
            $.each(s.annotations, function(aix, a) {
               // Annotation a
               var cls = a.code[0] == "T" ? " class='warning'" : "";
               right += "<div id='a" + annSpan.length + "'" + cls + ">" +
                  formatAnnotation(a.text) + "</div>\n";
               // Add a path to the canvas (empty at this point
               // but will be defined in repositionAnnotations())
               canvas += "<path id='p" + annSpan.length + "'" + cls + "></path>\n";
               // Note the token span to which the annotation applies,
               // within the global token list
               annSpan.push({ start: six + a.start, end: six + a.end });
            });
            // Finish sentence
            left += "</span>\n";
         });
         x += "<div class='result'>" + left + "</div>\n";
         x += "<div class='annotation'>" + right + "</div>\n";
         if (canvas) {
            // Encapsulate the paths in svg/g elements...
            canvas = "\n<svg width='100%' height='100%'><g>\n" + canvas + "</g></svg>\n";
            // and then within a canvas div
            x += "<div class='canvas'>" + canvas + "</div>\n";
         }
         // Finish paragraph
         x += "</div>\n"; // div class='correct'
      });
      // Show the text and annotation columns
      $("div#pgs").html(x);
      if (!annSpan.length) {
         // No annotations: show that fact
         $("#no-annotations").css("display", "inline-block");
      }
      // Fix the annotations so that they are never
      // above their respective start token
      repositionAnnotations();
      $(window).resize(repositionAnnotations);
      // Put a hover handler on each annotation
      $("div.annotation div").hover(annHoverIn, annHoverOut);
      // Put a click handler on each sentence
      $("span.sent").click(showParse);
   }

   function repositionAnnotations() {
      // Reposition the annotations to align
      // with their respective tokens. This function
      // is called both when the annotations are originally
      // positioned, and when the browser window is resized.
      // Begin by clearing any previous top margins
      $.each(annSpan, function(six) {
         var ann = $("#a" + six);
         ann.css("margin-top", "0");
      });
      // Then, align with tokens as necessary
      $.each(annSpan, function(six, span) {
         var tokenTop = $("#w" + span.start).offset().top;
         var spanEnd = span.end;
         // If the last token is a punctuation token,
         // try to go back to the previous word token
         // (it looks nicer and more consistent)
         while (spanEnd > span.start && w[spanEnd].k == TOK_PUNCTUATION)
            spanEnd--;
         var endToken = $("#w" + spanEnd);
         var tokenOffset = endToken.offset();
         var tokenY = tokenOffset.top + endToken.outerHeight();
         var tokenX = tokenOffset.left + endToken.outerWidth() / 2;
         var ann = $("#a" + six);
         var annOffset = ann.offset();
         var annTop = annOffset.top;
         var annX = annOffset.left;
         if (annTop < tokenTop) {
            // Put a top margin on the annotation to make its
            // top align with the token's top
            ann.css("margin-top", "" + (tokenTop - annTop) + "px");
            annTop = tokenTop;
         }
         // Work out the coordinates of a path from the span's
         // end token to the corresponding annotation
         var annY = annTop + ann.outerHeight() / 2;
         // Make the coordinates relative to the parent div.correct
         var parentOffset = ann.parents("div.correct").offset();
         tokenX -= parentOffset.left;
         tokenY -= parentOffset.top + 2; // Small upwards nudge for the start point
         annX -= parentOffset.left;
         annY -= parentOffset.top;
         // Make the path point from the end token to the
         // associated annotation. We position the Bezier curve
         // handles 40 pixels from the end points, below the end
         // token and to the left of the annotation.
         var path = $("#p" + six);
         path.attr("d",
            "M " + tokenX + " " + tokenY + 
            " C " + tokenX + " " + (tokenY + 40) +
            " " + (annX - 40) + " " + annY +
            " " + annX + " " + annY
         );
      });
   }

   function populateResult(json) {
      wait(false);
      if (!json.valid || json.result === undefined || json.result === null)
         $("div#pgs").html("<p><b>Villa kom upp</b> í samskiptum við netþjón Greynis</p>");
      else {
         // Display the paragraphs, sentences and tokens
         // along with the sentence-level annotations
         displayAnnotations(json.result);
         populateStats(json.stats);

         // Replace text in text field
         if (json.text) {
            $("#txt").val(json.text);
         }
      }
   }

   function correctText(txt) {
      // Ask the server to tokenize and parse the given text
      clearResult();
      // Launch the query
      serverQuery('/correct.api', // Endpoint with .api suffix are not cached
         {
            text : txt
         },
         populateResult,
         null,
         handleError
      );
   }

   function correct() {
      // Submit the contents of the textarea to the server
      // for tokenization and parsing
      var s = $("#txt").val().trim();
      if (s && s.length) {
         correctText(s);
      } else {
         $("#txt").focus();
      }
   }

   function selectFile() {
      $('#file-input').trigger('click');
   }

   function uploadFile() {
      var fd = new FormData();
      fd.set('file', $('#file-input')[0].files[0]);
      $("#txt").val("");
      wait(true, "#file-ok");
      $.ajax({
         url: '/correct.api',  
         type: 'POST',
         data: fd,
         success:populateResult,
         error:handleError,
         cache: false,
         contentType: false,
         processData: false
      });
   }

   function init() {
      // Activate the top navbar
      $("#navid-correct").addClass("active");
   }

   $(document).ready(init);

</script>

{% endblock %}

